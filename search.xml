<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>写给妻子</title>
      <link href="/2019/11/04/2019-11-04-xie-gei-qi-zi/"/>
      <url>/2019/11/04/2019-11-04-xie-gei-qi-zi/</url>
      
        <content type="html"><![CDATA[<p>遇见你，是我这辈子最大的惊喜。和你相知相守，是我此生最大幸福</p><p>清风轻轻的拂过了我的耳畔，在岁月的深处我用柔情续写了诗韵留香。一场风花雪月的浪漫，一段唯美的誓言，你陪着我走了很久很久，你陪着我走了很远很远。在浮世沧桑中，你我相遇相知相恋，时光流逝，见证着你我执子之手与子偕老的承诺。</p>]]></content>
      
      
      <categories>
          
          <category> 家书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家书 </tag>
            
            <tag> 心灵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简析Storm-Spark-Flink及如何保证不丢数据</title>
      <link href="/2018/08/10/2018-08-10-jian-xi-storm-spark-flink-ji-ru-he-bao-zheng-bu-diu-shu-ju/"/>
      <url>/2018/08/10/2018-08-10-jian-xi-storm-spark-flink-ji-ru-he-bao-zheng-bu-diu-shu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="简析Storm-Spark-Flink及如何保证不丢数据"><a href="#简析Storm-Spark-Flink及如何保证不丢数据" class="headerlink" title="简析Storm-Spark-Flink及如何保证不丢数据"></a>简析Storm-Spark-Flink及如何保证不丢数据</h1><h1 id="1-带着问题分享"><a href="#1-带着问题分享" class="headerlink" title="1.带着问题分享"></a>1.带着问题分享</h1><h2 id="1-1-如何保证不丢数据，实时计算几种语义的实现"><a href="#1-1-如何保证不丢数据，实时计算几种语义的实现" class="headerlink" title="1.1.如何保证不丢数据，实时计算几种语义的实现?"></a>1.1.如何保证不丢数据，实时计算几种语义的实现?</h2><h2 id="1-2-Storm-如何保证数据不丢"><a href="#1-2-Storm-如何保证数据不丢" class="headerlink" title="1.2.Storm 如何保证数据不丢?"></a>1.2.Storm 如何保证数据不丢?</h2><h2 id="1-3-Storm-如何保证数据不重复"><a href="#1-3-Storm-如何保证数据不重复" class="headerlink" title="1.3.Storm 如何保证数据不重复?"></a>1.3.Storm 如何保证数据不重复?</h2><h2 id="1-4-Storm-如何保证数据分支-分组"><a href="#1-4-Storm-如何保证数据分支-分组" class="headerlink" title="1.4.Storm 如何保证数据分支,分组?"></a>1.4.Storm 如何保证数据分支,分组?</h2><h2 id="1-5-Spark-Flink是如何实现的"><a href="#1-5-Spark-Flink是如何实现的" class="headerlink" title="1.5.Spark-Flink是如何实现的?"></a>1.5.Spark-Flink是如何实现的?</h2><h2 id="1-6-Storm-Spark-Flink使用场景"><a href="#1-6-Storm-Spark-Flink使用场景" class="headerlink" title="1.6.Storm-Spark-Flink使用场景?"></a>1.6.Storm-Spark-Flink使用场景?</h2><h1 id="2-如何保证不丢数据，实时计算几种语义的实现"><a href="#2-如何保证不丢数据，实时计算几种语义的实现" class="headerlink" title="2.如何保证不丢数据，实时计算几种语义的实现"></a>2.如何保证不丢数据，实时计算几种语义的实现</h1><p>At most once - 每条数据最多被处理一次（0次或1次）<br>At least once - 每条数据最少被处理一次 (1次或更多)<br>Exactly once - 每条数据只会被处理一次（没有数据会丢失，并且没有数据会被多次处理）</p><p><img src="http://otferhktu.bkt.clouddn.com/%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2.png" alt="storm"></p><h1 id="3-简单介绍Storm-Spark-Flink"><a href="#3-简单介绍Storm-Spark-Flink" class="headerlink" title="3.简单介绍Storm-Spark-Flink"></a>3.简单介绍Storm-Spark-Flink</h1><h2 id="3-1-Storm"><a href="#3-1-Storm" class="headerlink" title="3.1.Storm"></a>3.1.Storm</h2><h3 id="3-1-1-Storm-简单介绍-work-count举例"><a href="#3-1-1-Storm-简单介绍-work-count举例" class="headerlink" title="3.1.1.Storm-简单介绍-work count举例"></a>3.1.1.Storm-简单介绍-work count举例</h3><p><img src="http://otferhktu.bkt.clouddn.com/storm1.png" alt="storm"></p><p>spout：负责从数据源接收数据<br>bolt：负责数据处理，最下游的bolt负责数据输出</p><p>spout不断从数据源接收数据，然后按一定规则发送给下游的bolt进行计算，最下游的bolt将最终结果输出到外部系统中（这里假设输出到DB），这样我们在DB中就可以看到最新的数据统计结果。<br>Storm每一层的算子都可以配置多个，这样保证的水平扩展性。</p><h2 id="3-1-2-Storm-容灾"><a href="#3-1-2-Storm-容灾" class="headerlink" title="3.1.2.Storm-容灾"></a>3.1.2.Storm-容灾</h2><p>容灾是所有系统都需要考虑的一个问题，考虑一下：假如运行过程中，一个算子（bolt）因某种原因挂了，Storm如何恢复这个任务呢？<br><img src="http://otferhktu.bkt.clouddn.com/storm2.png" alt="storm"></p><p>批处理解决方案就比较简单，拿MR举例，假如一个运行中map或reduce失败，那么任务重新提交一遍就ok（只不过重头计算又要花费大量时间），下面我们看看Storm是如何解决的：<br>storm的spout有一个buffer，会缓存接收到的record，并且Storm还有一个acker（可以认为是一个特殊的bolt任务），每条record和该record所产生的所有tuple在处理完成后都会向对应的acker发送ack消息，当acker接收到该record所有的ack消息之后，便认为该record处理成功，并通知spout从buffer中将该record移除，若receiver没有在规定的时间内接收到ack，acker则通知spout重放数据。</p><h2 id="3-1-3-Storm-数据不重不丢"><a href="#3-1-3-Storm-数据不重不丢" class="headerlink" title="3.1.3.Storm-数据不重不丢"></a>3.1.3.Storm-数据不重不丢</h2><p><img src="http://otferhktu.bkt.clouddn.com/storm3.png" alt="storm"></p><p>sink处的重复输出：假如运行过程中，boltA数据入库后，boltB因为某种原因crash了，这时候会导致该record重放，boltA中已经处理过的数据会再次入库，导致部分数据重复输出。</p><p>不仅sink处存在重复输出的问题，receiver处也同样存在这种问题。</p><p>那么有没有一种架构，可以满足高吞吐、低延迟的要求，同时也提供exactly once功能？有的，下面我们来看看Spark streaming。</p><h2 id="3-2-Spark"><a href="#3-2-Spark" class="headerlink" title="3.2.Spark"></a>3.2.Spark</h2><h2 id="3-3-Flink"><a href="#3-3-Flink" class="headerlink" title="3.3.Flink"></a>3.3.Flink</h2><h2 id="4-Storm-Spark-Flink-对比及使用场景"><a href="#4-Storm-Spark-Flink-对比及使用场景" class="headerlink" title="4.Storm-Spark-Flink 对比及使用场景"></a>4.Storm-Spark-Flink 对比及使用场景</h2>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根本原因分析</title>
      <link href="/2018/05/22/09-fang-fa-lun/01-gong-zuo-fang-fa/2018-05-22-gen-ben-yuan-yin-fen-xi/"/>
      <url>/2018/05/22/09-fang-fa-lun/01-gong-zuo-fang-fa/2018-05-22-gen-ben-yuan-yin-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-根本原因分析-概念"><a href="#1-根本原因分析-概念" class="headerlink" title="1.根本原因分析-概念"></a>1.根本原因分析-概念</h1><blockquote><p>根本原因分析(Root Cause Analysis)是一项结构化的问题处理法，用以逐步找出问题的根本原因并加以解决， 而不是仅仅关注问题的表征。根本原因分析是一个系统化的问题处理过程，包括确定和分析问题原因，找出问题解决办法，并制定问题预防措施。在组织管理领域内，根本原因分析能够帮助利益相关者发现组织问题的症结，并找出根本性的解决方案。</p></blockquote><h1 id="2-根本原因分析-应用"><a href="#2-根本原因分析-应用" class="headerlink" title="2.根本原因分析-应用"></a>2.根本原因分析-应用</h1><blockquote><p>组织的多数疑难杂症都有不止于一种应对之法， 这些各不相同的解决之法，对于组织来说亦有不同程度的资源需求。 因为这种关联性的存在，就需要有一种最为有利的方案，能够快速解决妥善地解决问题。</p></blockquote><blockquote><p>因此，只顾解决表面原因、而不管根本原因的解决之法成为一种普遍现象，就不足为怪了。 然而，选择这种急功近利的问题解决办法，治标不治本，问题免不了要复发，其结果是组织不得不一而再、再而三地重复应对同一个问题。可以想象，这些方法的累积成本肯定是惊人的。</p></blockquote><h1 id="3-根本原因分析-目标"><a href="#3-根本原因分析-目标" class="headerlink" title="3.根本原因分析-目标"></a>3.根本原因分析-目标</h1><blockquote><p>根本原因分析法的目标是找出：</p></blockquote><blockquote><ul><li>问题（发生了什么）；</li><li>原因（为什么发生）；</li><li>措施（什么办法能够阻止问题再次发生）。</li></ul></blockquote><blockquote><p>所谓根本原因，就是导致我们所关注的问题发生的最基本的原因。因为引起问题的原因通常有很多，物理条件、人为因素、系统行为、或者流程因素等等，通过科学分析，有可能发现不止一个根源性原因。　　</p></blockquote><h1 id="4-根本原因分析-步骤"><a href="#4-根本原因分析-步骤" class="headerlink" title="4.根本原因分析-步骤"></a>4.根本原因分析-步骤</h1><blockquote><p>根本原因分析法最常见的一项内容是，提问为什么会发生当前情况， 并对可能的答案进行记录。 然而，再逐一对每个答案问一个为什么，并记录下原因。根本原因分析法的目的就是要努力找出问题的作用因素，并对所有的原因进行分析。这种方法通过反复问一个为什么，能够把问题逐渐引向深入，直到你发现根本原因。</p></blockquote><blockquote><p>找到根本原因后，就要进行下一个步骤： 评估改变根本原因的最佳方法，从而从根本上解决问题。 这是另一个独立的过程，一般被称之为 改正和预防。当我们在寻找根本原因的时候，必须要记住对每一个业已找出的原因也要进行评估，给出改正的办法，因为这样做也将有助于整体改善和提高。</p></blockquote><blockquote><p>根本原因分析作为一个一般性的术语，存在着一系列不尽相同的结构化的具体方法，用于解决具体的组织问题。　　</p></blockquote><h1 id="5-根本原因分析-工具"><a href="#5-根本原因分析-工具" class="headerlink" title="5.根本原因分析-工具"></a>5.根本原因分析-工具</h1><h2 id="5-1．因果图。"><a href="#5-1．因果图。" class="headerlink" title="5.1．因果图。"></a>5.1．因果图。</h2><blockquote><p>这是一种描述一个结果和所有可能对它有影响的原因之间的关系的方法，其步骤包括：定义问题，作图，描述所有相关的任务，复核图表，确定纠正行动。</p></blockquote><h2 id="5-2．头脑风暴法。"><a href="#5-2．头脑风暴法。" class="headerlink" title="5.2．头脑风暴法。"></a>5.2．头脑风暴法。</h2><blockquote><p>头脑风暴法是揭示所有可能的原因和所有的选择方案并导出纠正措施的最有效的一种方法。</p></blockquote><blockquote><p>头脑风暴法规则：决不批评任何一个想法；快速地写下每个想法并保持思维流畅；鼓励在他人的意见的基础上提出想法；鼓励发散性的思考；将规则张贴在团队成员都能看见的地方。指派一个记录员将各种想法写在纸上，要使讨论充满乐趣，记住即使愚蠢的想法也可能引发他人想到一个有用的点子。</p></blockquote><h2 id="5-3．因果分析——鱼骨图。"><a href="#5-3．因果分析——鱼骨图。" class="headerlink" title="5.3．因果分析——鱼骨图。"></a>5.3．因果分析——鱼骨图。</h2><blockquote><ul><li>（1）清楚地陈述问题或目标；</li><li>（2）确认三到六个主要的原因类别；</li><li>（3）运用头脑风暴法在每个类别下填写原因,并将每个原因联系到主要类别上去；</li><li>（4）针对每个原因思考可能对其起作用的因素,把这些因素放在从原因出发的一条线上；</li><li>（5）讨论每个因素和它如何对某个原因起作用，将该信息列在原因旁；</li><li>（6）对最可能的原因达成一致,将它们圈出来，寻找那些重复出现的原因；</li><li>（7）同意将采取的步骤，以收集数据确认原因或通过采取纠正措施消除原因。</li></ul></blockquote><h2 id="5-4．因果分析——WHY-WHY图。"><a href="#5-4．因果分析——WHY-WHY图。" class="headerlink" title="5.4．因果分析——WHY-WHY图。"></a>5.4．因果分析——WHY-WHY图。</h2><p><a href="http://wiki.mbalib.com/wiki/WHY-WHY%E5%9B%BE" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/WHY-WHY%E5%9B%BE</a>　　</p><h3 id="问题描述-5W2H法"><a href="#问题描述-5W2H法" class="headerlink" title="问题描述- 5W2H法"></a>问题描述- 5W2H法</h3><table><thead><tr><th>5W2H</th><th>说明</th></tr></thead><tbody><tr><td>what</td><td>发生了什么问题</td></tr><tr><td>Who</td><td>谁发现的</td></tr><tr><td>Where</td><td>在哪里发现的</td></tr><tr><td>When</td><td>什么时候发现的</td></tr><tr><td>Why</td><td>为什么它是个问题</td></tr><tr><td>How</td><td>怎么发现的</td></tr><tr><td>How much</td><td>发现了多少</td></tr></tbody></table><blockquote><p>这是一种简单却有效的方法，通过层层分解原因找出导致一个问题不断发生的根本原因,主要有四个步骤：选择问题，该问题为何出现，那些原因为何发生，找出最重要的原由（可能不只一个）。</p></blockquote><h3 id="WHY-WHY图使用概述："><a href="#WHY-WHY图使用概述：" class="headerlink" title="WHY-WHY图使用概述："></a>WHY-WHY图使用概述：</h3><blockquote><ul><li>（1）确定问题或目标的，把它写在图的最左边的一个方框内，要确保所有成员都知道这个问题或目标。</li><li>（2）确定原因或任务，写在方框的右边的分枝上。</li><li>（3）继续阐明原因或任务，并在右边画上新的分枝。</li><li>（4）重复上述步骤直到每个分枝到达它的逻辑终点。</li><li>（5）检查树状图，确定是否需要增加其它信息或者在层次上是否有欠缺的地方。</li><li>（6）制定行动计划。</li></ul></blockquote><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6.参考资料"></a>6.参考资料</h1><ul><li>《精益创业》第十一章,有对五个为什么方法的精彩解读，推荐！</li><li><a href="http://wiki.mbalib.com/wiki/根本原因分析" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/根本原因分析</a></li><li><a href="http://en.wikipedia.org/wiki/5_Whys" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/5_Whys</a></li><li><a href="http://wiki.mbalib.com/wiki/5_Whys" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/5_Whys</a></li><li>美团点评的文档-说的很详细:<br><a href="https://tech.meituan.com/5whys-method.html" target="_blank" rel="noopener">https://tech.meituan.com/5whys-method.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发流程标准</title>
      <link href="/2018/05/15/03-xiang-mu-guan-li/2018-05-15-xiang-mu-kai-fa-liu-cheng-biao-zhun/"/>
      <url>/2018/05/15/03-xiang-mu-guan-li/2018-05-15-xiang-mu-kai-fa-liu-cheng-biao-zhun/</url>
      
        <content type="html"><![CDATA[<h2 id="0-1-需求评审前-下发需求"><a href="#0-1-需求评审前-下发需求" class="headerlink" title="0.1. 需求评审前,下发需求."></a>0.1. 需求评审前,下发需求.</h2><h2 id="0-2-了解需求-做相关调研-业务-技术-数据等调研"><a href="#0-2-了解需求-做相关调研-业务-技术-数据等调研" class="headerlink" title="0.2. 了解需求,做相关调研(业务,技术,数据等调研)."></a>0.2. 了解需求,做相关调研(业务,技术,数据等调研).</h2><hr><h2 id="1-需求评审-干系人-产品PM-测试QA-开发RD"><a href="#1-需求评审-干系人-产品PM-测试QA-开发RD" class="headerlink" title="1. 需求评审(干系人:产品PM+测试QA+开发RD)."></a>1. 需求评审(干系人:产品PM+测试QA+开发RD).</h2><h2 id="2-接口设计"><a href="#2-接口设计" class="headerlink" title="2.接口设计."></a>2.接口设计.</h2><h2 id="3-设计文档编写-概要设计文档等"><a href="#3-设计文档编写-概要设计文档等" class="headerlink" title="3.设计文档编写(概要设计文档等)."></a>3.设计文档编写(概要设计文档等).</h2><h2 id="4-内部设计评审-包含前后端接口设计评审"><a href="#4-内部设计评审-包含前后端接口设计评审" class="headerlink" title="4.内部设计评审. (包含前后端接口设计评审)."></a>4.内部设计评审. (包含前后端接口设计评审).</h2><h2 id="5-开发排期"><a href="#5-开发排期" class="headerlink" title="5.开发排期."></a>5.开发排期.</h2><h2 id="6-开发-接口开发-sdk开发"><a href="#6-开发-接口开发-sdk开发" class="headerlink" title="6.开发(接口开发 | sdk开发)."></a>6.开发(接口开发 | sdk开发).</h2><h2 id="7-测试用例评审-产品-开发-测试"><a href="#7-测试用例评审-产品-开发-测试" class="headerlink" title="7.测试用例评审(产品+开发+测试)"></a>7.测试用例评审(产品+开发+测试)</h2><h2 id="9-代码评审-每天评审"><a href="#9-代码评审-每天评审" class="headerlink" title="9.代码评审(每天评审)."></a>9.代码评审(每天评审).</h2><h2 id="10-自测-P0级Bug"><a href="#10-自测-P0级Bug" class="headerlink" title="10.自测(P0级Bug)."></a>10.自测(P0级Bug).</h2><h2 id="11-联调环境准备"><a href="#11-联调环境准备" class="headerlink" title="11.联调环境准备"></a>11.联调环境准备</h2><h2 id="12-联调-排期时-bug修改时间"><a href="#12-联调-排期时-bug修改时间" class="headerlink" title="12.联调(排期时+bug修改时间)."></a>12.联调(排期时+bug修改时间).</h2><h2 id="13-测试环境准备"><a href="#13-测试环境准备" class="headerlink" title="13.测试环境准备."></a>13.测试环境准备.</h2><h2 id="14-测试介入"><a href="#14-测试介入" class="headerlink" title="14.测试介入."></a>14.测试介入.</h2><h2 id="15-Bug修改"><a href="#15-Bug修改" class="headerlink" title="15.Bug修改."></a>15.Bug修改.</h2><h2 id="16-风险时间-评估风险点-额外"><a href="#16-风险时间-评估风险点-额外" class="headerlink" title="16.风险时间(评估风险点+额外)"></a>16.风险时间(评估风险点+额外)</h2><h2 id="17-功能测试完成-产品验收-回归测试"><a href="#17-功能测试完成-产品验收-回归测试" class="headerlink" title="17.功能测试完成(产品验收 + 回归测试)"></a>17.功能测试完成(产品验收 + 回归测试)</h2><h2 id="18-数据准备"><a href="#18-数据准备" class="headerlink" title="18.数据准备."></a>18.数据准备.</h2><h2 id="19-上线计划-checklist及上线"><a href="#19-上线计划-checklist及上线" class="headerlink" title="19.上线计划,checklist及上线."></a>19.上线计划,checklist及上线.</h2><h2 id="20-产品验收-测试跟进"><a href="#20-产品验收-测试跟进" class="headerlink" title="20.产品验收 + 测试跟进."></a>20.产品验收 + 测试跟进.</h2><h2 id="21-跟进"><a href="#21-跟进" class="headerlink" title="21.跟进."></a>21.跟进.</h2>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流程 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 标准 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写技术博客</title>
      <link href="/2018/04/28/09-fang-fa-lun/2018-04-28-ru-he-xie-ji-zhu-bo-ke/"/>
      <url>/2018/04/28/09-fang-fa-lun/2018-04-28-ru-he-xie-ji-zhu-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="如何写技术博客"><a href="#如何写技术博客" class="headerlink" title="如何写技术博客"></a>如何写技术博客</h1><p> 作者: 刘江</p><p> 美团技术学院院长。在技术媒体和图书行业工作将近20年。</p><p> 曾任CSDN首席战略官、CSDN与《程序员》杂志总编。图灵公司联合创始人和创始总编。机械工业出版社华章公司副总编。</p><hr><p> 软技能：代码之外的生存指南</p><ol><li><p>技术文章的作用</p><ul><li>文章是最基本也是强大的信息工具</li><li>文字显性表达有助于深入与思考</li></ul></li><li><p>好的技术文章标准（joel test）</p><ul><li>干货</li><li>好理解</li></ul></li><li><p>写什么</p><ul><li>写给谁看（小，专业，某个点到优秀）</li><li>解决他们什么问题</li><li>同主题有些文章</li><li>我的文章有什么增值</li><li>这篇文章会有人朋友圈转发</li></ul></li><li><p>常见的文章类型</p><ul><li>故事（case study，参与感想）</li><li>观点 why</li><li>实操 how to</li><li>原理 how works</li><li>评论（图书、技术、方法）</li></ul></li><li><p>怎么写</p><ul><li>标题：与受众有关</li><li>金字塔结构</li><li>简洁，清晰，节奏感</li></ul></li><li><p>基本原则</p><ul><li>不要比喻隐喻</li><li>一个字，词能说清楚，不要两个字</li><li>用主动，不要被动</li><li>用常用词</li><li>不要粗鲁</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给博客文章分类</title>
      <link href="/2018/04/28/09-fang-fa-lun/2018-04-28-ru-he-gei-bo-ke-wen-zhang-fen-lei/"/>
      <url>/2018/04/28/09-fang-fa-lun/2018-04-28-ru-he-gei-bo-ke-wen-zhang-fen-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="如何给博客文章分类"><a href="#如何给博客文章分类" class="headerlink" title="如何给博客文章分类"></a>如何给博客文章分类</h1><h2 id="按照-内容-分类"><a href="#按照-内容-分类" class="headerlink" title="按照 * 内容 * 分类"></a>按照 * 内容 * 分类</h2><ul><li><p>生活</p><ul><li></li></ul></li><li><p>技术</p><ul><li>前端</li><li>后端</li><li>大数据</li><li>高并发</li><li>算法</li></ul></li><li><p>技术感悟</p><ul><li>故事(case study，参会感想)</li><li>观点(why)</li><li>实操(how to)</li><li>原理(how works)</li><li>评论(图书、技术、方法)</li></ul></li><li><p>PB编程能力</p></li><li><p>PB调试能力</p></li><li><p>PB编译部署能力</p></li><li><p>P性能优化能力    </p></li><li><p>P业务架构能力</p></li><li><p>P在线运维能力</p></li><li><p>P项目管理能力</p></li><li><p>P规划能力</p></li><li><p>T团队管理</p></li><li><p>T公司运营</p></li><li><p>方法论</p></li><li><p>理论</p></li><li><p>工具</p></li></ul><h2 id="按照-来源分类-分类"><a href="#按照-来源分类-分类" class="headerlink" title="按照 * 来源分类 * 分类"></a>按照 * 来源分类 * 分类</h2><ul><li>原创</li><li>摘录</li><li>评论</li><li>总结</li><li>笔记</li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Better Java</title>
      <link href="/2017/09/06/2017-09-06-better-java/"/>
      <url>/2017/09/06/2017-09-06-better-java/</url>
      
        <content type="html"><![CDATA[<h1 id="Better-Java"><a href="#Better-Java" class="headerlink" title="Better Java"></a>Better Java</h1><p>Java 虽作为最流行的编程语言之一，但是似乎并没有什么人很享受用它。好吧，Java 确实是这样的一门编程语言，从最近发布不久的 Java 8 开始，为了更好的使用 Java，我决定收集一些库，实践和工具等相关资料。“更好” 是主观的，所以推荐使用我所说的建议的某些部分，而不是一下子全部按照这些建议来做。请尽情添加其他意见并提交 PR。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#style">Style（风格）</a><ul><li><a href="#structs">Structs（结构）</a><ul><li><a href="#the-builder-pattern">The Builder Pattern（构建器模式）</a></li><li><a href="#immutable-object-generation">Immutable Object Generation（不可变对象生成）</a></li></ul></li><li><a href="#exceptions">Exceptions（异常）</a></li><li><a href="#dependency-injection">Dependency injection（依赖注入）</a></li><li><a href="#avoid-nulls">Avoid Nulls（避免空值）</a></li><li><a href="#immutable-by-default">Immutable-by-default（默认不可变）</a></li><li><a href="#avoid-lots-of-util-classes">Avoid lots of Util classes（避免过多的工具类）</a></li><li><a href="#formatting">Formatting（格式）</a><ul><li><a href="#javadoc">Javadoc</a></li></ul></li><li><a href="#streams">Streams（流）</a></li></ul></li><li><a href="#deploying">Deploying（部署）</a><ul><li><a href="#frameworks">Frameworks（框架）</a></li><li><a href="#maven">Maven</a><ul><li><a href="#dependency-convergence">Dependency Convergence（依赖收敛）</a></li></ul></li><li><a href="#continuous-integration">Continuous Integration（持续集成）</a></li><li><a href="#maven-repository">Maven repository（Maven 仓库）</a></li><li><a href="#configuration-management">Configuration management（配置管理）</a></li></ul></li><li><a href="#libraries">Libraries（库）</a><ul><li><a href="#missing-features">Missing Features（缺失的特性）</a><ul><li><a href="#apache-commons">Apache Commons</a></li><li><a href="#guava">Guava</a></li><li><a href="#gson">Gson</a></li><li><a href="#java-tuples">Java Tuples（Java 元组）</a></li><li><a href="#javaslang">Javaslang</a></li><li><a href="#joda-time">Joda-Time</a></li><li><a href="#lombok">Lombok</a></li><li><a href="#play-framework">Play framework（Play 框架）</a></li><li><a href="#slf4j">SLF4J</a></li><li><a href="#jooq">jOOQ</a></li></ul></li><li><a href="#testing">Testing（测试）</a><ul><li><a href="#junit-4">jUnit 4</a></li><li><a href="#jmock">jMock</a></li><li><a href="#assertj">AssertJ</a></li></ul></li></ul></li><li><a href="#tools">Tools（工具）</a><ul><li><a href="#intellij-idea">IntelliJ IDEA</a><ul><li><a href="#chronon">Chronon</a></li></ul></li><li><a href="#jrebel">JRebel</a></li><li><a href="#the-checker-framework">The Checker Framework（检查框架）</a></li><li><a href="#code-quality">Code Quality（代码质量）</a></li><li><a href="#eclipse-memory-analyzer">Eclipse Memory Analyzer（Eclipse 内存分析）</a></li></ul></li><li><a href="#resources">Resources（资源）</a><ul><li><a href="#books">Books（书）</a></li><li><a href="#podcasts">Podcasts（播客）</a></li><li><a href="#videos">Videos（视频）</a></li></ul></li></ul><h2 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h2><p>Java 传统的代码风格是被用来编写非常复杂的企业级 JavaBean。新的代码风格看起来会更加整洁，更加正确，并且更加简单。</p><h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>对我们程序员来说，包装数据是最简单的事情之一。下面是传统的通过定义一个 JavaBean 的实现方式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DataHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方式既繁琐又浪费代码。即使你的 IDE 可以自动生成这些代码，也是浪费。因此，<a href="http://www.javapractices.com/topic/TopicAction.do?Id=84" target="_blank" rel="noopener">别这么干</a>.</p><p>相反，我更喜欢 C 语言保存数据的风格来写一个类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DataHolder</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样不仅减少了近一半的代码行数。并且，这个类里面保存的数据除了你去继承它，否则不会改变，由于它不可变性，我们可以认为这会更加简单。</p><p>如果你想保存很容易修改的对象数据，像 Map 或者 List，你应该使用 ImmutableMap 或者 ImmutableList，这些会在不变性那一部分讨论。</p><h4 id="The-Builder-Pattern"><a href="#The-Builder-Pattern" class="headerlink" title="The Builder Pattern"></a>The Builder Pattern</h4><p>如果你想用这种构造的方式构造更复杂的对象，请考虑构建器模式。</p><p>你可以建一个静态内部类来构建你的对象。构建器构建对象的时候，对象的状态是可变的，但是一旦你调用了 build 方法之后，构建的对象就变成了不可变的了。</p><p>想象一下我们有一个更复杂的 <em>DataHolder</em>。那么它的构建器看起来应该是这样的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComplicatedDataHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// lots more fields and a constructor</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String data<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">public</span> Builder <span class="token function">data</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">num</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> ComplicatedDataHolder <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ComplicatedDataHolder</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// etc</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后调用它：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> ComplicatedDataHolder cdh <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComplicatedDataHolder<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"set this"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token number">523</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这有<a href="http://jlordiales.me/2012/12/13/the-builder-pattern-in-practice/" target="_blank" rel="noopener">关于构建器更好的例子</a>，他会让你感受到构建器到底是怎么回事。它没有使用许多我们尽力避免使用的样板，并且它会给你不可变的对象和非常好用的接口。</p><p>可以考虑下在众多的库中选择一个来帮你生成构建器，取代你亲手去写构建器的方式。</p><h4 id="Immutable-Object-Generation"><a href="#Immutable-Object-Generation" class="headerlink" title="Immutable Object Generation"></a>Immutable Object Generation</h4><p>如果你要手动创建许多不可变对象，请考虑用注解处理器的方式从它们的接口自动生成。它使样板代码减少到最小化，减少产生 bug 的可能性，促进了对象的不可变性。看这 <a href="https://docs.google.com/presentation/d/14u_h-lMn7f1rXE1nDiLX0azS3IkgjGl5uxp5jGJ75RE/edit#slide=id.g2a5e9c4a8_00" target="_blank" rel="noopener">presentation</a> 有常见的 Java 设计模式中一些问题的有趣的讨论。</p><p>一些非常棒的代码生成库如 [immutables]<br>(<a href="https://github.com/immutables/immutables" target="_blank" rel="noopener">https://github.com/immutables/immutables</a>), 谷歌的<br><a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="noopener">auto-value</a> 和<br><a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a></p><h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>使用<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html" target="_blank" rel="noopener">检查</a>异常的时候一定要注意，或者干脆别用。它会强制你去用 try/catch 代码块包裹住可能抛出异常的部分。比较好的方式就是使你自定义的异常继承自运行时异常来取而代之。这样，可以让你的用户使用他们喜欢的方式去处理异常，而不是每次抛出异常的时候都强制它们去处理/声明，这样会污染代码。</p><p>一个比较漂亮的绝招是在你的方法异常声明中声明 RuntimeExceptions。这对编译器没有影响，但是可以通过文档告诉你的用户在这里可能会有异常抛出。</p><h3 id="Dependency-injection"><a href="#Dependency-injection" class="headerlink" title="Dependency injection"></a>Dependency injection</h3><p>在软件工程领域，而不仅是在 Java 领域，使用<a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">依赖注入</a>是编写可测试软件最好的方法之一。<br>由于 Java 强烈鼓励使用面向对象的设计，所以在 Java 中为了开发可测试软件，你不得不使用依赖注入。</p><p>在 Java 中，通常使用<a href="http://projects.spring.io/spring-framework/" target="_blank" rel="noopener">Spring 框架</a>来完成依赖注入。Spring 有基于代码的和基于 XML 配置文件的两种连接方式。如果你使用基于 XML 配置文件的方式，注意不要<a href="http://programmers.stackexchange.com/questions/92393/what-does-the-spring-framework-do-should-i-use-it-why-or-why-not" target="_blank" rel="noopener">过度使用 Spring</a>，正是由于它使用的基于 XML 配置文件的格式。在 XML 配置文件中绝对不应该有逻辑或者控制结构。它应该仅仅被用来做依赖注入。</p><p>使用 Google 和 Square 的 <a href="http://square.github.io/dagger/" target="_blank" rel="noopener">Dagger</a> 或者 Google 的 <a href="https://github.com/google/guice" target="_blank" rel="noopener">Guice</a> 库是 Spring 比较好的替代品。它们不使用像 Spring 那样的 XML 配置文件的格式，相反它们把注入逻辑以注解的方式写到代码中。</p><h3 id="Avoid-Nulls"><a href="#Avoid-Nulls" class="headerlink" title="Avoid Nulls"></a>Avoid Nulls</h3><p>尽量避免使用空值。不要返回 null 的集合，你应该返回一个 empty 的集合。如果你确实准备使用 null 请考虑使用 <a href="https://github.com/google/guice/wiki/UseNullable" target="_blank" rel="noopener">@Nullable</a> 注解。<a href="http://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a> 内置支持 @Nullable 注解。</p><p>阅读<a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/" target="_blank" rel="noopener">计算机科学领域最糟糕的错误</a>了解更多为何不使用 null。</p><p>如果你使用的是 Java 8，你可以用新出的优秀的 <a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" target="_blank" rel="noopener">Optional</a> 类型。如果有一个值你不确定是否存在，你可以像这样在类中用 <em>Optional</em> 包裹住它们：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooWidget</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String data<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Optional<span class="token operator">&lt;</span>Bar<span class="token operator">></span> bar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooWidget</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> Optional<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">FooWidget</span><span class="token punctuation">(</span>String data<span class="token punctuation">,</span> Optional<span class="token operator">&lt;</span>Bar<span class="token operator">></span> bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> bar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Optional<span class="token operator">&lt;</span>Bar<span class="token operator">></span> <span class="token function">getBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> bar<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样，现在你可以清晰地知道 <em>data</em> 肯定不为 null，但是 <em>bar</em> 不清楚是不是存在。<em>Optional</em> 有如 <em>isPresent</em> 这样的方法，可以用来检查是否为 <em>null</em>，感觉和原来的方式并没有太大区别。但是它允许你可以这样写：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Optional<span class="token operator">&lt;</span>FooWidget<span class="token operator">></span> fooWidget <span class="token operator">=</span> <span class="token function">maybeGetFooWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> Baz baz <span class="token operator">=</span> fooWidget<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>FooWidget<span class="token operator">:</span><span class="token operator">:</span>getBar<span class="token punctuation">)</span>                         <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>BarWidget<span class="token operator">:</span><span class="token operator">:</span>getBaz<span class="token punctuation">)</span>                         <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>defaultBaz<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样比写一连串的判断是否为空的检查代码更好。使用 Optional 唯一不好的是标准库对 Optional 的支持并不是很好，所以对 null 的处理仍然是必要的。</p><h3 id="Immutable-by-default"><a href="#Immutable-by-default" class="headerlink" title="Immutable-by-default"></a>Immutable-by-default</h3><p>变量，类和集合应该设置为不可变的，除非你有很好的理由去修改他们。</p><p>变量可以用 <em>final</em> 关键字使起不可变：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> FooWidget fooWidget<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fooWidget <span class="token operator">=</span> <span class="token function">getWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        fooWidget <span class="token operator">=</span> cachedFooWidget<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CachingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Couldn't get cached value"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// fooWidget is guaranteed to be set here</span></code></pre><p>现在你可以确定 fooWidget 对象不会意外地被重新赋值了。<em>final</em> 关键词也可以在 if/else 和 try/catch 代码块中使用。当然，如果 <em>fooWidget</em> 对象本身不是不可变的，你可以很容易去修改它。</p><p>使用集合的时候，任何可能的情况下尽量使用 Guava 的 <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableMap.html" target="_blank" rel="noopener">ImmutableMap</a>, <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableList.html" target="_blank" rel="noopener">ImmutableList</a>, 或者<br><a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableSet.html" target="_blank" rel="noopener">ImmutableSet</a> 类。这些类都有构建器，你可以很容易地动态构建集合，一旦你执行了 build 方法，集合就变成了不可变的。</p><p>类应该声明不可变的字段（通过 <em>final</em> 实现）和不可变的集合使该类不可变。或者，可以对类本身使用 <em>final</em> 关键词，这样这个类就不会被继承也不会被修改了。</p><h3 id="Avoid-lots-of-Util-classes"><a href="#Avoid-lots-of-Util-classes" class="headerlink" title="Avoid lots of Util classes"></a>Avoid lots of Util classes</h3><p>如果你发现在你正在往工具类中添加很多方法，就要注意了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MiscUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">frobnicateString</span><span class="token punctuation">(</span>String base<span class="token punctuation">,</span> <span class="token keyword">int</span> times<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ... etc</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">throwIfCondition</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> condition<span class="token punctuation">,</span> String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ... etc</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>乍一看这些工具类似乎很不错，因为里面的那些方法放在别处确实都不太合适。因此，你以可重用代码的名义全放这了。</p><p>这个想法比本身这么做还要糟糕。请把这些类放到它应该在的地方去并积极重构。不要命名一些像 “MiscUtils” 或者 “ExtrasLibrary” 这样的很普通的类，包或者库。这会鼓励产生无关代码。</p><h3 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h3><p>格式化代码对大多数程序员来说并没有它应有的那么重要。统一化你的代码格式对阅读你的代码的人有帮助吗？当然了。但是别在为了 if 代码块匹配添加空格上耗一天。</p><p>如果你确实需要一个代码格式风格的教程，我高度推荐 <a href="http://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener">Google’s Java Style</a> 这个教程。写的最好的部分是 <a href="http://google.github.io/styleguide/javaguide.html#s6-programming-practices" target="_blank" rel="noopener">Programming Practices</a>。绝对值得一读。</p><h4 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h4><p>文档对对你代码的阅读着来说也很重要。这意味着你要给出<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/ImmutableMap.Builder.html" target="_blank" rel="noopener">使用示例</a>，并且给出你的变量，方法和类清晰地描述。</p><p>这样做的必然结果是不要对不需要写文档的地方填写文档。如果你对一个参数的含义没什么可说的，或者它本身已经很明显是什么意思了，就不要为其写文档了。统一样板的文档比没有文档更加糟糕，这样会让读你代码的人误以为那就是文档。</p><h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p><a href="http://www.java8.org/" target="_blank" rel="noopener">Java 8</a> 有很棒的 <a href="http://blog.hartveld.com/2013/03/jdk-8-33-stream-api.html" target="_blank" rel="noopener">stream</a> and lambda 语法。你可以像这样来写代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>取代这样的写法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> filtered <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        filtered<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它让你可以写更多的流畅的代码，并且可读性更高。</p><h2 id="Deploying"><a href="#Deploying" class="headerlink" title="Deploying"></a>Deploying</h2><p>Java 的部署问题确实有点棘手。现如今有两种主流的方式：使用框架或者灵活性更高的内部研发的解决方案。</p><h3 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h3><p>由于 Java 的部署并不容易，所以使用框架还是很有帮助的。最好的两个框架是 <a href="https://dropwizard.github.io/dropwizard/" target="_blank" rel="noopener">Dropwizard</a> 和 <a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">Spring Boot</a>。<a href="https://www.playframework.com/" target="_blank" rel="noopener">Play 框架</a> 也可以被看作为一种部署框架。</p><p>这些框架都是尽力地降低你部署代码的壁垒。它们对 Java 新手或者想提高效率的人尤有帮助。单独的 JAR 包部署会比复杂的 WAR 包或者 EAR 包部署更简单一点。</p><p>然而，这些框架并没有你想象的那么灵活，如果你的项目的开发者选择的框架并不合适，你不得不迁移到手动配置更多的部署方案上来。</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p><strong>不错的替代工具</strong>: <a href="http://gradle.org/" target="_blank" rel="noopener">Gradle</a>.</p><p>Maven 仍然是构建，打包和测试的标准。有很多不错的替代工具，如 Gradle，但是他们同样都没有像 Maven 那样的适应性。如果你是 Maven 新手，你应该从<a href="http://books.sonatype.com/mvnex-book/reference/index.html" target="_blank" rel="noopener">Maven 实例</a>这里开始。</p><p>我喜欢用一个根 POM（Project Object Model，项目对象模型）来管理所有用到的外部依赖。它会像<a href="https://gist.github.com/cxxr/10787344" target="_blank" rel="noopener">这个样子</a>。这个根 POM 仅仅包含一个外部依赖，但是如果你的产品足够大，你将会有几十个外部依赖了。你的根 POM 应该像其他 Java 项目一样采用版本控制和发布的方式，有一个自己的项目。</p><p>如果你认为你的根 POM 每添加一个外部依赖都打上一个标签很麻烦，那你肯定没有遇到过为了排查依赖错误引起的问题，浪费一周的时间翻遍整个项目的情况。</p><p>你所有的 Maven 项目都应该包含你的根 POM，以及这些项目的所有版本信息。这样你会清除地了解到你们公司选择的每一个外部依赖的版本，以及所有正确的 Maven 插件。如果你要引入很多的外部依赖，它将会是这样子的：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.third.party<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>some-artifact<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>如果你想使用内部依赖，它应该被每一个单独项目的 <strong><dependencyManagement></strong> 部分来管理。否则那将会很难保持根 POM 的版本号是正常的。</p><h4 id="Dependency-Convergence"><a href="#Dependency-Convergence" class="headerlink" title="Dependency Convergence"></a>Dependency Convergence</h4><p>Java 最好的一方面就是拥有大量的第三方库可以做任何事。基本上每一个 API 或者工具包都有一个 Java SDK，可以很方便的用 Maven 引入。</p><p>并且这些第三方 Java 库本身依赖特定版本的其他的库。如果你引入足够多的库，你会发现有些库的版本是冲突的，像这样：</p><pre><code>Foo library depends on Bar library v1.0Widget library depends on Bar library v0.9</code></pre><p>你的项目到底要引入哪一个版本呢？</p><p>如果你的项目依赖于不同版本的同一个库，使用 <a href="https://maven.apache.org/enforcer/enforcer-rules/dependencyConvergence.html" target="_blank" rel="noopener">Maven 依赖趋同插件</a>构建时将会报错。然后你有两个方案来解决这个冲突：</p><ol><li>在你的 <em>dependencyManagement</em> 部分明确地支出你所使用的 Bar 的版本号</li><li>在 FOO 或者 Widget 中排除对 Bar 的依赖。</li></ol><p>这两个方案到底选哪一个要看你面对的是什么情况：如果你想跟踪一个项目的版本，那么选择排除的方案是不错的。另一方面，如果你想明确地指出它，你可以选择一个版本，尽管你在需要更新其他依赖的时候也需要更新它。</p><h3 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h3><p>很明显，你需要某种形式的持续集成服务器来帮你不断构建你的快照版本和基于 git 标签构建。</p><p><a href="http://jenkins-ci.org/" target="_blank" rel="noopener">Jenkins</a> 和 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a> 就成了很自然的选择.</p><p>代码覆盖率非常有用，<a href="http://cobertura.github.io/cobertura/" target="_blank" rel="noopener">Cobertura</a> 就有 <a href="http://mojo.codehaus.org/cobertura-maven-plugin/usage.html" target="_blank" rel="noopener">一个很好的 Maven 插件</a><br><a href="http://mojo.codehaus.org/cobertura-maven-plugin/usage.html" target="_blank" rel="noopener">a good Maven plugin</a> 并且支持 CI。还有一些其他的支持 Java 的代码覆盖率工具，但是我只用过 Cobertura。</p><h3 id="Maven-repository"><a href="#Maven-repository" class="headerlink" title="Maven repository"></a>Maven repository</h3><p>你需要一个地方存储你生成的 JAR 包，WAR 包或者 EAR 包，因此，你需要一个仓库。</p><p>一般选择有 <a href="http://www.jfrog.com/" target="_blank" rel="noopener">Artifactory</a> 和 <a href="http://www.sonatype.com/nexus" target="_blank" rel="noopener">Nexus</a> 这两个。它们都可以用，但是它们都有着各自的优缺点。</p><p>你应该有自己的 Artifactory/Nexus 设备和<a href="http://www.jfrog.com/confluence/display/RTF/Configuring+Artifacts+Resolution" target="_blank" rel="noopener">镜像</a> 使你的依赖基于此。这样就不会由于上游的 Maven 库宕机而使你的构建崩溃了。</p><h3 id="Configuration-management"><a href="#Configuration-management" class="headerlink" title="Configuration management"></a>Configuration management</h3><p>现在，你的代码已经编译完了，你的仓库也跑起来了，最终你需要把你的代码从开发环境部署到生产环境了。到了这里，千万不要吝啬，因为将来很长一段时间，你会从这些自动化方式中尝到很多的甜头。</p><p><a href="https://www.chef.io/chef/" target="_blank" rel="noopener">Chef</a>，<a href="https://puppetlabs.com/" target="_blank" rel="noopener">Puppet</a>，和 <a href="http://www.ansible.com/home" target="_blank" rel="noopener">Ansible</a> 是很典型的选择。我曾经也写了一个叫 <a href="http://www.gosquadron.com" target="_blank" rel="noopener">Squadron</a> 的也可供选择，当然，我认为你应该仔细看看这个，因为它使用起来比其他的更为简单方便。</p><p>无论你选择了什么工具，不要忘了使你的部署实现自动化。</p><h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><p>对 Java 来说，拥有大量的扩展库也许是最大的特点了。下面这些一小部分的扩展库对大部分人来说很适用的。</p><h3 id="Missing-Features"><a href="#Missing-Features" class="headerlink" title="Missing Features"></a>Missing Features</h3><p>Java 标准库曾经作出过惊人的改进，但是现在来看，它仍然缺少一些关键的特性。</p><h4 id="Apache-Commons"><a href="#Apache-Commons" class="headerlink" title="Apache Commons"></a>Apache Commons</h4><p><a href="http://commons.apache.org/" target="_blank" rel="noopener">Apache Commons 项目</a> 拥有大量的有用的扩展库。</p><p><strong>Commons Codec</strong> 对 Base64 和 16 进制字符串来说有很多有用的编/解码方法。不要再浪费时间重写这些东西了。</p><p><strong>Commons Lang</strong> 有许多关于字符串的操作和创建，字符集和许多各种各样的实用的方法。</p><p><strong>Commons IO</strong> 拥有所有你能想到的关于文件操作的方法。有<br><a href="http://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/FileUtils.html#copyDirectory(java.io.File,%20java.io.File)" target="_blank" rel="noopener">FileUtils.copyDirectory</a>，<a href="http://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/FileUtils.html#writeStringToFile(java.io.File,%20java.lang.String)" target="_blank" rel="noopener">FileUtils.writeStringToFile</a>，<a href="http://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/IOUtils.html#readLines(java.io.InputStream)" target="_blank" rel="noopener">IOUtils.readLines</a> 和更多实用的方法。</p><h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><p><a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a> 是谷歌优秀的对 Java 标准库缺少的特性进行补充的扩展库。虽然这很难提炼总结出我有多喜欢这个库，但是我会尽力的。</p><p><strong>Cache</strong> 让你可以用很简单的方法，实现把网络访问，磁盘访问，缓存函数或者其他任何你想要缓存的内容，缓存到内存当中。你仅仅只需要实现 <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/cache/CacheBuilder.html" target="_blank" rel="noopener">CacheBuilder</a> 类并且告诉 Guava 怎么样构建你的缓存，一切就搞定了！</p><p><strong>Immutable</strong> 集合。它有许多如：<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableMap.html" target="_blank" rel="noopener">ImmutableMap</a>，<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableList.html" target="_blank" rel="noopener">ImmutableList</a>，或者甚至 <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/ImmutableSortedMultiset.html" target="_blank" rel="noopener">ImmutableSortedMultiSet</a> 等不可变集合可以使用，如果你喜欢用这种风格的话。</p><p>我也喜欢用 Guava 的方式来写一些可变的集合：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Instead of</span><span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Widget<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// You can use</span><span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Widget<span class="token operator">></span> map <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>它还有一些静态类如 <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Lists.html" target="_blank" rel="noopener">Lists</a>，<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Maps.html" target="_blank" rel="noopener">Maps</a>和<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Sets.html" target="_blank" rel="noopener">Sets</a> 等。使用起来它们显得更整洁，并且可读性更强。</p><p>如果你坚持使用 Java 6 或者 7 的话，你可以使用 <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Collections2.html" target="_blank" rel="noopener">Collections2</a> 这个类，它有一些像 filter 和 transform 这样的方法。能够让你没有 Java 8 的 Stream 的支持也能写出流畅的代码。</p><p>Guava 也可以做一些很简单的事情，比如 <strong>Joiner</strong> 类可以用来用分隔符把字符串拼接起来，并且可以用忽略的方式<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Uninterruptibles.html" target="_blank" rel="noopener">来处理打断程序</a>的数据。</p><h4 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h4><p>谷歌的 <a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a> 库是一个简单快速的 JSON 解析库。可以这样用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> String json <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>fooWidget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> FooWidget newFooWidget <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> FooWidget<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这用起来真的很简单，很愉悦。<a href="https://sites.google.com/site/gson/gson-user-guide" target="_blank" rel="noopener">Gson 用户手册</a> 有很多的使用示例。</p><h4 id="Java-Tuples"><a href="#Java-Tuples" class="headerlink" title="Java Tuples"></a>Java Tuples</h4><p>Java 令我比较烦恼的问题之一 Java 标准库中没有内置对元组的支持。幸运的是，<a href="http://www.javatuples.org/" target="_blank" rel="noopener">Java tuples</a> 项目解决了这个问题。</p><p>它使用用起来很简单，很棒：</p><pre class=" language-java"><code class="language-java">Pair<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span>String input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// something...</span>    <span class="token keyword">return</span> Pair<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>stringResult<span class="token punctuation">,</span> intResult<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Javaslang"><a href="#Javaslang" class="headerlink" title="Javaslang"></a>Javaslang</h4><p><a href="http://javaslang.com/" target="_blank" rel="noopener">Javaslang</a> 是一个函数式编程库，它被设计用来弥补本应该出现在 Java 8 中但缺失的一些特性。它有这样的一些特点：</p><ul><li>一个全新函数式集合库</li><li>紧密集成的元组功能</li><li>模式匹配</li><li>通过不可变性保证线程安全</li><li>饥汉式和懒汉式的数据类型</li><li>通过 Option 实现了 null 的安全性</li><li>通过 Try 更好的实现异常处理</li></ul><p>有一些 Java 库依赖于原始的 Java 集合类。它们通过以面向对象和被设计为可变的方式来保证和其他的类的兼容性。而 Javaslang 的集合的设计灵感来源于  Haskell, Clojure 和 Scala，是一个全新的飞跃。它们被设计为函数式风格并且遵循不可变性的设计风格。</p><p>像下面这样的代码就可以自动实现线程安全，并且不用 try-catch 语句处理异常：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Success/Failure containing the result/exception</span><span class="token keyword">public</span> <span class="token keyword">static</span> Try<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Try<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> DB<span class="token punctuation">.</span><span class="token function">findUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">recover</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> Match<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">whenType</span><span class="token punctuation">(</span>RemoteException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">whenType</span><span class="token punctuation">(</span>SQLException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Thread-safe, reusable collections</span><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">sayByeBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"bye, "</span>bye<span class="token string">", "</span>collect<span class="token string">", "</span>mania"<span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">intersperse</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda-Time"></a>Joda-Time</h4><p><a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener">Joda-Time</a> 是我用过的最简单的时间处理库。简单，直接，并且很容易测试。夫复何求？</p><p>因为 Java 8 已经有了自己的新的 <a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" target="_blank" rel="noopener">时间处理</a>库， 所以如果你还没有用 Java 8，你需要这一个库足矣。</p><h4 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h4><p><a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a> 是一个很有意思的库。它可以让你以注解的方式减少 Java 中糟糕的样板代码。</p><p>想为你的类的变量添加 setter 和 getter 方法吗？像这样：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Getter</span> <span class="token annotation punctuation">@Setter</span> <span class="token keyword">private</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在你就可以这么用了：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Foo foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">setVar</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这还有<a href="http://jnb.ociweb.com/jnb/jnbJan2010.html" target="_blank" rel="noopener">很多</a>例子。我在之前的产品中还没有用过 Lombok，但是现在我等不急了。</p><h4 id="Play-framework"><a href="#Play-framework" class="headerlink" title="Play framework"></a>Play framework</h4><p><strong>好的替代品</strong>: <a href="https://jersey.java.net/" target="_blank" rel="noopener">Jersey</a> 或者 <a href="http://sparkjava.com/" target="_blank" rel="noopener">Spark</a></p><p>在 Java 实现 RESTful web services 有两大主要阵营：<a href="https://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services" target="_blank" rel="noopener">JAX-RS</a> 和其他。</p><p>JAX-RS 是传统的实现方式。你可以用像 <a href="https://jersey.java.net/" target="_blank" rel="noopener">Jersey</a> 这样的框架，以注解的方式来实现接口及其实现的结合。这样你就可以很容易的根据接口类来开发客户端。</p><p><a href="https://www.playframework.com/" target="_blank" rel="noopener">Play 框架</a> 基于 JVM 的 web services 实现和其他根本框架不同：它有一个路由文件，你写的类要和路由文件中的路由信息关联起来。Play 框架其实是一个<a href="https://www.playframework.com/documentation/2.3.x/Anatomy" target="_blank" rel="noopener">完整的 MVC 框架</a>，但是你可以很简单地仅仅使用它的 REST web services 部分的功能。</p><p>它同时支持 Java 和 Scala。虽然对重点支持的 Scala 稍有不足，但是对 Java 的支持还是很好用的。</p><p>如果你在 Python 中用过像 Flask 这样的微框架，你对 <a href="http://sparkjava.com/" target="_blank" rel="noopener">Spark</a> 肯定会很熟悉。它对 Java 8 的支持尤其的好。</p><h4 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h4><p>有很多 Java 日志解决方案。我最喜欢的是 <a href="http://www.slf4j.org/" target="_blank" rel="noopener">SLF4J</a>，因为它拥有非常棒的可插拔性，同时能够和很多的日志框架想结合。有没有做过同时使用 java.util.logging，JCL，和 log4j 的奇葩项目？SLF4J 就是为你而生。</p><p>这<a href="http://www.slf4j.org/manual.html" target="_blank" rel="noopener">两页手册</a>足够你可以开始入门使用 SLF4J 了。</p><h4 id="jOOQ"><a href="#jOOQ" class="headerlink" title="jOOQ"></a>jOOQ</h4><p>我不喜欢重量级的 ORM 框架，因为我喜欢 SQL。所以我写了很多 <a href="http://docs.spring.io/spring/docs/4.0.3.RELEASE/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html" target="_blank" rel="noopener">JDBC 模板</a>，但是很难去维护它。<a href="http://www.jooq.org/" target="_blank" rel="noopener">jOOQ</a> 是一个更好的解决方案。</p><p>它让你在 Java 中用类型安全的方式编写 SQL：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Typesafely execute the SQL statement directly with jOOQ</span>Result<span class="token operator">&lt;</span>Record3<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">,</span> String<span class="token operator">>></span> result <span class="token operator">=</span> create<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>BOOK<span class="token punctuation">.</span>TITLE<span class="token punctuation">,</span> AUTHOR<span class="token punctuation">.</span>FIRST_NAME<span class="token punctuation">,</span> AUTHOR<span class="token punctuation">.</span>LAST_NAME<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>BOOK<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>AUTHOR<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>BOOK<span class="token punctuation">.</span>AUTHOR_ID<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>AUTHOR<span class="token punctuation">.</span>ID<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span>BOOK<span class="token punctuation">.</span>PUBLISHED_IN<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">1948</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 jOOQ 和 <a href="http://www.javapractices.com/topic/TopicAction.do?Id=66" target="_blank" rel="noopener">DAO</a> 的模式让你的数据库访问变得轻而易举。</p><h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>测试是软件的关键环节。下面这些软件包能够让你更容易地测试。</p><h4 id="jUnit-4"><a href="#jUnit-4" class="headerlink" title="jUnit 4"></a>jUnit 4</h4><p><strong>好的替代品</strong>：<a href="http://testng.org" target="_blank" rel="noopener">TestNG</a>.</p><p><a href="http://junit.org/" target="_blank" rel="noopener">jUnit</a> 就无需多言了。它是 Java 单元测试中的标准工具。</p><p>但是很可能你使用的 jUnit 并没有发挥它的全部潜力。jUnit 支持<a href="https://github.com/junit-team/junit/wiki/Parameterized-tests" target="_blank" rel="noopener">参数化测试</a>，<a href="https://github.com/junit-team/junit/wiki/Rules" target="_blank" rel="noopener">规则化</a>测试，<a href="https://github.com/junit-team/junit/wiki/Theories" target="_blank" rel="noopener">theories</a> 可以随机测试特定代码，还有 <a href="https://github.com/junit-team/junit/wiki/Assumptions-with-assume" target="_blank" rel="noopener">assumptions</a>，可以让你少写很多样板代码。</p><h4 id="jMock"><a href="#jMock" class="headerlink" title="jMock"></a>jMock</h4><p>如果你完成了依赖注入，这是它的回报：可以 mock 出有副作用（比如和 REST 服务器交互）的代码，并且可以断言调用这段代码的行为。</p><p><a href="http://www.jmock.org/" target="_blank" rel="noopener">jMock</a> 是标准的 Java mock 工具。像这样使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooWidgetTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Mockery context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mockery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">basicTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> FooWidgetDependency dep <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span>FooWidgetDependency<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">checking</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Expectations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>            <span class="token function">oneOf</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token function">any</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">atLeast</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">optionalCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> FooWidget foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FooWidget</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">doThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">assertIsSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码通过 jMock 建立了一个 <em>FooWidgetDependency*，然后添加你所期望结果的条件。我们期望 *dep</em> 的 <em>call</em> 方法会被以一个字符串为参数的形式调用，并且会被调用 0 次或者多次。</p><p>如果你想一遍又一遍地设置相同的依赖，你应该把它放到 <a href="https://github.com/junit-team/junit/wiki/Test-fixtures" target="_blank" rel="noopener">test fixture</a> 中，并且把<em>assertIsSatisfied</em> 放在以 <em>@After</em> 注解的 fixture 中。</p><h4 id="AssertJ"><a href="#AssertJ" class="headerlink" title="AssertJ"></a>AssertJ</h4><p>你曾经用 jUnit 干过这个吗？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> some<span class="token punctuation">.</span><span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"some result"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"some other result"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertFalse</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"shouldn't be here"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这是很恶心的样板代码。<a href="http://joel-costigliola.github.io/assertj/index.html" target="_blank" rel="noopener">AssertJ</a> 可以解决这个问题。你可以把相同的代码转换成这个样子：</p><pre class=" language-java"><code class="language-java"><span class="token function">assertThat</span><span class="token punctuation">(</span>some<span class="token punctuation">.</span><span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasSize</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"some result"</span><span class="token punctuation">,</span> <span class="token string">"some other result"</span><span class="token punctuation">)</span>                             <span class="token punctuation">.</span><span class="token function">doesNotContain</span><span class="token punctuation">(</span><span class="token string">"shouldn't be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样的流畅接口让你的测试更具有可读性。你还想咋地？</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><p><strong>好的替代品</strong>: <a href="https://www.eclipse.org/" target="_blank" rel="noopener">Eclipse</a> 和 <a href="https://netbeans.org/" target="_blank" rel="noopener">Netbeans</a></p><p>Java 最好的 IDE 是 <a href="http://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a>。它有大量的牛逼的特性，它是真正的能让 Java 用来像不戴套做爱那么爽的工具。自动完成功能超棒，<a href="http://i.imgur.com/92ztcCd.png" target="_blank" rel="noopener">代码检查功能也是顶尖的</a>，重构工具那是相当有帮助。</p><p>免费的社区版对我来说已经足够好了，但是它的旗舰版加载了更多的牛逼的特性，如数据库工具，Spring 框架的支持和对 Chronon 的支持。</p><h4 id="Chronon"><a href="#Chronon" class="headerlink" title="Chronon"></a>Chronon</h4><p>我最喜欢 GDB 7 的特性之一就是调试的时候能够按照时间跟踪回来。当你拥有了旗舰版的 IntelliJ，你可以通过安装 <a href="http://blog.jetbrains.com/idea/2014/03/try-chronon-debugger-with-intellij-idea-13-1-eap/" target="_blank" rel="noopener">Chronon IntelliJ 插件</a>实现。</p><p>你可以获取到变量的变化历史，后退，方法的历史以及更多的信息。如果你是第一次用会觉得有点怪，但是它真的能够帮你解决很复杂的 bug，诸如海森堡类的 bug。</p><h3 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h3><p><strong>好的替代品</strong>: <a href="https://github.com/dcevm/dcevm" target="_blank" rel="noopener">DCEVM</a></p><p>持续集成往往以软件即服务为产品目标。想象一下如果你不用等待代码构建完成而能实时看到代码的变化会是怎样？</p><p>这就是 <a href="http://zeroturnaround.com/software/jrebel/" target="_blank" rel="noopener">JRebel</a> 所做的。一旦你将你的服务器和你的 JReble 以 hook 方式连接，你就可以从服务器看到实时变化。当你想快速试验的时候它能为你节省大量的时间。</p><h3 id="The-Checker-Framework"><a href="#The-Checker-Framework" class="headerlink" title="The Checker Framework"></a>The Checker Framework</h3><p>Java 的类型系统很差劲。它不能够区分正常的字符串和正则表达式字符串，更不用说<a href="https://en.wikipedia.org/wiki/Taint_checking" target="_blank" rel="noopener">坏点检查</a>了。不过 <a href="http://types.cs.washington.edu/checker-framework/" target="_blank" rel="noopener">Checker Framework</a> 可以完成这个功能并且能够实现更多的东西。</p><p>它使用像 <em>@Nullable</em> 这样的注解来检查类型。你甚至可以使用<a href="http://types.cs.washington.edu/checker-framework/tutorial/webpages/encryption-checker-cmd.html" target="_blank" rel="noopener">自定义注解</a>来实现静态分析，甚至更强大的功能。</p><h3 id="Code-Quality"><a href="#Code-Quality" class="headerlink" title="Code Quality"></a>Code Quality</h3><p>即使遵循着最佳实践的原则，即使是最好的开发者，也都会犯错误。这有很多工具，你可以使用它们验证你的代码从而检查代码是否有问题。下面是选出的最流行的一部分工具。很多这些工具都可以和流行的 IDE 如 Eclipse 或者 IntelliJ 集成，可以让你更快地发现代码中的错误。</p><ul><li><strong><a href="http://checkstyle.sourceforge.net/" target="_blank" rel="noopener" title="Checkstyle">Checkstyle</a></strong>：一个静态代码分析工具，它主要着力于保证你的代码符合代码标准。检查规则在一个 XML 文件中定义，你可以把它检入你的版本控制工具，和你的代码放在一起。</li><li><strong><a href="http://findbugs.sourceforge.net/" target="_blank" rel="noopener" title="FindBugs">FindBugs</a></strong>：主要集中于发现你的代码中可能导致产生 bug 或者错误的部分。虽然作为独立的进程运行，但是对流行的 IDE 和构建工具的支持也很好。</li><li><strong><a href="https://pmd.github.io/" target="_blank" rel="noopener" title="PMD">PMD</a></strong>：和 FindBugs 很相似，PMD 着力于发现你代码中的错误和整理的你的代码。你可以把针对你的代码的检查规则控制在 XML 文件中，和你的代码放在一块儿提交。</li><li><strong><a href="http://www.sonarqube.org/" target="_blank" rel="noopener" title="SonarQube">SonarQube</a></strong>：和前面所述的工具不同，它是在本地运行的，SonarQube 启动一个服务器，你把你代码提交到这个服务器来进行分析。它提供了 web 界面，你可以看到你的代码的健康状况信息，如不好的做法，潜在的 bug，测试覆盖率百分比，和你写代码的<a href="https://en.wikipedia.org/wiki/Technical_debt" target="_blank" rel="noopener" title="Technical Debt on Wikipedia">技术水平</a></li></ul><p>除了在开发工程中使用这些工具，把它们用在你的构建阶段往往也是一个不错的想法。它可以和想 Maven 或者 Gradle 这样的构建工具绑定到一起，也可以和持续集成工具绑定使用。</p><h3 id="Eclipse-Memory-Analyzer"><a href="#Eclipse-Memory-Analyzer" class="headerlink" title="Eclipse Memory Analyzer"></a>Eclipse Memory Analyzer</h3><p>即使在 Java 中内存泄露也时有发生。幸运的是，我们有一些工具就是为此而生。<a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">Eclipse Memory Analyzer</a> 是我用过的最好用的解决内存泄露问题的工具。它能够获取到堆栈信息让你查阅，去发现问题所在。</p><p>有几种方法可以获取到 JVM 进程的堆栈信息，但是我用 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html" target="_blank" rel="noopener">jmap</a> 工具实现：</p><pre class=" language-bash"><code class="language-bash">$ jmap -dump:live,format<span class="token operator">=</span>b,file<span class="token operator">=</span>heapdump.hprof -F 8152Attaching to process ID 8152, please wait<span class="token punctuation">..</span>.Debugger attached successfully.Server compiler detected.JVM version is 23.25-b01Dumping heap to heapdump.hprof <span class="token punctuation">..</span>.<span class="token punctuation">..</span>. snip <span class="token punctuation">..</span>.Heap dump <span class="token function">file</span> created</code></pre><p>然后你可以用内存分析器打开 <em>heapdump.hprof</em> 文件，快看看到底是怎么回事。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>这些资源能够帮你成为 Java 大牛。</p><h3 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h3><ul><li><a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683" target="_blank" rel="noopener">Effective Java</a></li><li><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601" target="_blank" rel="noopener">Java Concurrency in Practice</a></li><li><a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/" target="_blank" rel="noopener">Clean Code</a></li></ul><h3 id="Podcasts"><a href="#Podcasts" class="headerlink" title="Podcasts"></a>Podcasts</h3><ul><li><a href="http://www.javaposse.com/" target="_blank" rel="noopener">The Java Posse</a> (<em>discontinued</em>)</li><li><a href="http://virtualjug.com/" target="_blank" rel="noopener">vJUG</a></li><li><a href="https://lescastcodeurs.com/" target="_blank" rel="noopener">Les Cast Codeurs</a> (<em>French</em>)</li><li><a href="http://www.javapubhouse.com/" target="_blank" rel="noopener">Java Pub House</a></li><li><a href="http://www.javaoffheap.com/" target="_blank" rel="noopener">Java Off Heap</a></li><li><a href="http://www.enterprisejavanews.com" target="_blank" rel="noopener">Enterprise Java Newscast</a></li></ul><h3 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h3><ul><li><a href="https://www.youtube.com/watch?v=V1vQf4qyMXg" target="_blank" rel="noopener">Effective Java - Still Effective After All These Years</a></li><li><a href="http://www.infoq.com/" target="_blank" rel="noopener">InfoQ</a> - see especially <a href="http://www.infoq.com/java/presentations/" target="_blank" rel="noopener">presentations</a> and <a href="http://www.infoq.com/java/interviews/" target="_blank" rel="noopener">interviews</a></li><li><a href="https://www.parleys.com/" target="_blank" rel="noopener">Parleys</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP</title>
      <link href="/2017/08/15/2017-08-15-tu-jie-http-yue-du-bi-ji/"/>
      <url>/2017/08/15/2017-08-15-tu-jie-http-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h1><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul><li>GET 获取资源</li><li>POST 传输实体主体</li><li>PUT 传输文件</li><li>HEAD 获得报文首部</li><li>DELETE 删除we那件</li><li>OPTIONS 询问支持的方法</li><li>TRACE 追踪路径</li><li>CONNECT 要求用隧道协议连接代理 (CONNECT 代理服务器名:端口号 HTTP版本)</li></ul><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ul><li>HTTP keep-alive 或 HTTPconnection reuse</li></ul><h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><ul><li>不等待响应,直接发送下一个请求</li></ul><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><ul><li>请求报文和响应报文</li></ul><ol><li>请求行</li><li>请求首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li><li>空行</li><li></li><li>报文主体</li></ol><hr><ol><li>状态行</li><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li><li>空行</li><li></li><li>报文主体</li></ol><h2 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h2><ul><li>gzip (GNU zip)</li><li>compress (UNIX 系统的标准压缩)</li><li>deflate (zlib)</li><li>identity (不进行编码)</li></ul><h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><ul><li>MIME  multipart/form-data    multipart/byteranges</li><li>获取部分内容的范围请求 range</li></ul><h2 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h2><hr><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务端无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务端错误状态码)</td><td>服务端处理请求错误</td></tr></tbody></table><ul><li><p>200 ok</p></li><li><p>204 No Content  请求处理成功! 但没有资源可返回</p><p>返回204 浏览器显示的页面不发生更新</p><p> (一般在只需要从客户端往服务器发送信息,而客户端不需要发送新信息内容的情况下使用.)  返回204 浏览器的页面不</p></li><li><p>206 Partial Content</p><p>该状态码标识客户端进行了范围请求,而服务器成功执行了这部分的GET请求.</p><p>响应报文中包含由Content-Range 指定范围的实体内容.</p></li><li><p>301 Moved Permanenttly  永久重定向</p><p>客户端需要进行书签引用的变更</p><p>资源的URI 已更新,你也更新下你的书签引用吧</p></li><li><p>302 Found  临时重定向</p><p>该状态表示请求的资源已被分配了新的URI,希望用户(本次)能使用新的URI访问.</p></li><li><p>303 See Other</p><p>服务器-资源的URI已更新,你是否能临时按新的URI访问?</p><p>303 和 302 有着相同的功能,但303 状态码明确表示客户端应当采用GET方法获取资源.</p></li><li><p>304 Not Modified 服务器端的资源未改变,可直接使用客户端未过期的缓存</p><p>304 返回时不包含任何响应的主体部分</p></li><li><p>307 Temporary Redirect 临时重定向</p><p>307 会遵照浏览器标准,不会从POST变成GET</p></li><li><p>400 Bad Request</p><p>该状态标识请求的报文中存在语法错误.</p></li><li><p>401 Unauthorized</p><p>该状态表示发送的请求需要有通过HTTP认证.</p></li></ul><ul><li><p>403 Forbidden</p><p>该状态码表明对请求资源的访问被服务器拒绝了.</p></li><li><p>404 Not Found  服务器没有请求的资源</p><p>也可以在服务端拒绝请求且不想说明理由时使用.</p></li><li><p>500 Internal Server Error   貌似,内部资源出故障了…</p><p>该状态码表明服务器端在执行请求时发生了错误.</p></li><li><p>503 Service Unavailable</p><p>表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求.</p><p>如果实现得知解除以上状况需要的时间,最好写入Retry-After 首部字段再返回给客户端.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站技术架构-核心原理与案例分析</title>
      <link href="/2017/08/15/2017-08-15-da-xing-wang-zhan-ji-zhu-jia-gou-he-xin-yuan-li-yu-an-li-fen-xi-yue-du-bi-ji/"/>
      <url>/2017/08/15/2017-08-15-da-xing-wang-zhan-ji-zhu-jia-gou-he-xin-yuan-li-yu-an-li-fen-xi-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="大型网站技术架构-核心原理与案例分析–-李智慧"><a href="#大型网站技术架构-核心原理与案例分析–-李智慧" class="headerlink" title="大型网站技术架构-核心原理与案例分析–(李智慧)"></a>大型网站技术架构-核心原理与案例分析–(李智慧)</h1><h2 id="1-大型网站结构演化"><a href="#1-大型网站结构演化" class="headerlink" title="1 大型网站结构演化"></a>1 大型网站结构演化</h2><h3 id="1-1-大型网站软件系统的特点"><a href="#1-1-大型网站软件系统的特点" class="headerlink" title="1.1 大型网站软件系统的特点"></a>1.1 大型网站软件系统的特点</h3><ul><li>高并发,大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛,网络情况复杂</li><li>安全环境恶劣</li><li>需求快速变更,发布频繁</li><li>渐进式发展</li></ul><h3 id="1-2-大型网站结构演化发展历程"><a href="#1-2-大型网站结构演化发展历程" class="headerlink" title="1.2 大型网站结构演化发展历程"></a>1.2 大型网站结构演化发展历程</h3><ul><li>初始阶段的网站架构 &gt; 单服务器 应用程序+文件+数据库</li><li>应用服务器和数据服务器分离</li><li>使用缓存改善网站性能</li><li>使用应用服务器集群改善王章的并发处理能力</li><li>数据库读写分离</li><li>使用反向代理和CDN加速网站响应</li><li>使用分布式文件系统和分布式数据库系统</li><li>使用NoSql和搜索引擎</li><li>业务拆分</li><li>分布式服务</li></ul><p>![image](001 - 较构图)</p><h3 id="1-3-大型网站架构演化的价值观"><a href="#1-3-大型网站架构演化的价值观" class="headerlink" title="1.3 大型网站架构演化的价值观"></a>1.3 大型网站架构演化的价值观</h3><ul><li>核心价值是随网站多需灵活应对</li><li>驱动大型网站技术发展的主要力量是网站的业务发展</li></ul><h3 id="1-4-网站架构设计误区"><a href="#1-4-网站架构设计误区" class="headerlink" title="1.4 网站架构设计误区"></a>1.4 网站架构设计误区</h3><ul><li>一味追随大公司的解决方案</li><li>为了技术而技术</li><li>企图用技术解决所有问题  &gt; 例如大数据量的分页,阿里在一定页数后直接返回null</li></ul><hr><h1 id="2-大型网站架构模式"><a href="#2-大型网站架构模式" class="headerlink" title="2 大型网站架构模式"></a>2 大型网站架构模式</h1><h2 id="2-1-网站架构模式"><a href="#2-1-网站架构模式" class="headerlink" title="2.1 网站架构模式"></a>2.1 网站架构模式</h2><ul><li>高性能</li><li>高可用 &gt; redis哨兵 &gt; mysql keepalived</li><li>易伸缩</li><li>可扩展 &gt; 雪花算法分布式ID</li><li>安全</li></ul><h3 id="2-1-1-分层"><a href="#2-1-1-分层" class="headerlink" title="2.1.1 分层"></a>2.1.1 分层</h3><ul><li>网络协议7层</li></ul><h3 id="2-1-2-分割"><a href="#2-1-2-分割" class="headerlink" title="2.1.2 分割"></a>2.1.2 分割</h3><ul><li>按照业务纵向分割</li></ul><h3 id="2-1-3-分布式"><a href="#2-1-3-分布式" class="headerlink" title="2.1.3 分布式"></a>2.1.3 分布式</h3><ul><li>分布式应用和服务</li><li>分布式静态资源 &gt; js css logo 独立域名</li><li>分布式数据和存储</li><li>分布式计算 &gt; MapReduce 移动计算而不是移动数据</li><li>分布式配置 &gt; config</li><li>分布式锁 &gt; 分布式环境下实现并发和协同</li><li>分布式文件 &gt; 云存储</li></ul><h3 id="2-1-4-集群"><a href="#2-1-4-集群" class="headerlink" title="2.1.4 集群"></a>2.1.4 集群</h3><ul><li>负载均衡实现集群</li></ul><h3 id="2-1-5-缓存"><a href="#2-1-5-缓存" class="headerlink" title="2.1.5 缓存"></a>2.1.5 缓存</h3><ul><li>CDN &gt; 即内容分发网络. 部署在距离终端用户最近的网络服务商,缓存静态资源</li><li>反向代理 &gt; 属于网站前端架构的一部分. 缓存网站的静态资源</li><li>本地缓存 &gt; 缓存热点数据. 使用本机内存缓存数据</li><li>分布式缓存 &gt; 缓存频繁访问的数据(统计数据访问)&gt; 数据在某一个时间段内有效,不会很快过期</li></ul><h3 id="2-1-6-异步"><a href="#2-1-6-异步" class="headerlink" title="2.1.6 异步"></a>2.1.6 异步</h3><ul><li>使用异步降低业务的耦合性</li><li>单一服务器内,可通过多线程共享内存队列的方式实现异步.处于业务操作前面的线程降输出写入到队列,后面的线程从队列中读取数据进行处理.</li><li>分布式系统,通过分布式消息队列实现异步.  RabbitMQ</li></ul><p>==作用==</p><ul><li>提高系统可用性 &gt; 消费服务器发生故障,数据会缓存在消息队列中.</li><li>加快网站的响应速度</li><li>消除并发访问高峰 &gt; 将并发访问放到消息队列中,等待消费者服务器处理.实现消峰</li></ul><h3 id="2-1-7-冗余"><a href="#2-1-7-冗余" class="headerlink" title="2.1.7 冗余"></a>2.1.7 冗余</h3><ul><li><p>服务集群 数据备份</p></li><li><p>冷备份 &gt; 定期存档保存</p></li><li><p>热备份 &gt; 主从分离,主从同步</p></li><li><p>灾备数据中心 &gt; 全球范围内部署</p></li></ul><h3 id="2-1-8-自动化"><a href="#2-1-8-自动化" class="headerlink" title="2.1.8 自动化"></a>2.1.8 自动化</h3><p>==发布过程自动化== &gt; 减少人为干预,减少故障</p><ul><li>自动化代码管理 &gt; 代码版本控制,代码分支创建合并等过程自动化. git 的加强 –&gt;todo</li><li>自动化测试</li><li>自动化安全检测 findbug</li><li>自动化部署</li><li>自动化监控</li><li>自动化报警</li><li>自动化失效转移 &gt; 将失效的服务器从集群中隔离出去</li><li>自动化失效不想恢复</li><li>自动化降级</li><li>自动化分配资源</li></ul><h3 id="2-1-9-安全"><a href="#2-1-9-安全" class="headerlink" title="2.1.9 安全"></a>2.1.9 安全</h3><ul><li>通过==密码==和==手机验证码==进行身份认证</li><li>登录,交易等操作,需要对网络进行通信加密</li><li>服务器上存储的==敏感数据==如用户信息进行加密</li><li>防止机器人攻击,使用==验证码==进行识别</li><li>对于常见的XSS攻击,SQL注入,进行编码转换等响应处理</li><li>对于垃圾信息,敏感信息进行==过滤==</li><li>对交易转账,进行==风险控制==</li></ul><h2 id="好的设计模式绝对不是模仿-不是生搬硬套某个模式-而是对问题深刻理解之上的创造与创新-即使是”微创新”-也是让人耳目一新的似曾相识"><a href="#好的设计模式绝对不是模仿-不是生搬硬套某个模式-而是对问题深刻理解之上的创造与创新-即使是”微创新”-也是让人耳目一新的似曾相识" class="headerlink" title="##好的设计模式绝对不是模仿,不是生搬硬套某个模式,而是对问题深刻理解之上的创造与创新,即使是”微创新”,也是让人耳目一新的似曾相识.##"></a>##好的设计模式绝对不是模仿,不是生搬硬套某个模式,而是对问题深刻理解之上的创造与创新,即使是”微创新”,也是让人耳目一新的似曾相识.##</h2><h1 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3 大型网站核心架构要素"></a>3 大型网站核心架构要素</h1><h2 id="3-1-性能"><a href="#3-1-性能" class="headerlink" title="3.1 性能"></a>3.1 性能</h2><p>==衡量指标==: 响应时间,并发数,吞吐量(TPS 每秒事务数,HPS 每秒http请求数,QPS 每秒查询数)等 OPS</p><ul><li>在浏览器端,可以通过浏览器缓存,使用页面压缩,合理布局页面,减少cookie传输等手段改善性能.</li><li>CDN 反向代理</li><li>在应用服务器端, 本地缓存,分布式缓存</li><li>异步操作</li><li>高并发请求下,集群</li><li>在代码层,多线程,改善内存管理</li><li>在数据库服务器端,索引,缓存,sql优化.  NoSQL</li></ul><h2 id="3-2-可用性-7X24可用"><a href="#3-2-可用性-7X24可用" class="headerlink" title="3.2 可用性 7X24可用"></a>3.2 可用性 7X24可用</h2><ul><li>预发布验证</li><li>自动化测试 &gt; 性能测试 负载测试 压力测试 稳定性测试</li><li>自动化发布</li><li>灰度发布  &gt; AB测试</li></ul><h2 id="3-3-伸缩性"><a href="#3-3-伸缩性" class="headerlink" title="3.3 伸缩性"></a>3.3 伸缩性</h2><h2 id="3-4-扩展性"><a href="#3-4-扩展性" class="headerlink" title="3.4 扩展性"></a>3.4 扩展性</h2><h2 id="3-5-安全性"><a href="#3-5-安全性" class="headerlink" title="3.5 安全性"></a>3.5 安全性</h2><hr><p>CAP 原理</p><ul><li>数据持久性</li><li>数据可访问性</li><li>数据一致性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发工具</title>
      <link href="/2017/08/10/2017-08-10-kai-fa-gong-ju/"/>
      <url>/2017/08/10/2017-08-10-kai-fa-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="开发辅助工具"><a href="#开发辅助工具" class="headerlink" title="开发辅助工具"></a>开发辅助工具</h1><ol><li><p>在线接口文档+接口测试工具:   <a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p></li><li><p>Easy Mock       <a href="https://easy-mock.com" target="_blank" rel="noopener">https://easy-mock.com</a></p></li><li><p>代码查找BUG工具:</p><p> 1&gt;FindBugs</p><p> 2&gt;SonarQube</p><p> Sonar是一个用于代码质量管理的开源平台，用于管理源代码的质量，可以从七个维度检测代码质量</p><p> 通过插件形式，可以支持包括java,C#,C/C++,PL/SQL,Cobol,JavaScrip,Groovy等等二十几种编程语言的代码质量管理与检测</p></li><li><p>代码格式化工具:CheckStyle</p></li><li><p>查找BUG解决方案(Stack Overflow)      <a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p></li><li><p>超实用压力测试工具－ab工具 <a href="http://httpd.apache.org/" target="_blank" rel="noopener">http://httpd.apache.org/</a></p></li></ol><hr><h1 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h1><ol><li><p>git管理服务器使用: GitLab</p></li><li><p>任务看板+周报:tower   (icafe 一般)</p></li><li><p>分享知识库: Confluence<br> 知识分享:<br> Confluence<br> 是一个专业的企业知识管理与协同软件，也可以用于构建企业wiki。通过它可以实现团队成员之间的协作和知识共享。</p></li><li><p>事故问题管理: jira</p></li><li><p>自己零碎任务: wunderlist</p></li><li><p>团队沟通,智能化工作流:  钉钉 dingding</p></li></ol><hr><h1 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h1><ol><li><p>在线画流程图　processon　<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></p></li><li><p>工作计划－甘特图：office project</p></li><li><p>脑图 xmind</p></li><li><p>StarUML</p><p> StarUML:可绘制9款UML图：用例图、类图、序列图、状态图、活动图、通信图、构件图、部署图以及复合结构图等。</p></li></ol><hr><h1 id="学习工具"><a href="#学习工具" class="headerlink" title="学习工具"></a>学习工具</h1><ol><li>在线做面试题  <a href="http://www.lintcode.com" target="_blank" rel="noopener">http://www.lintcode.com</a></li><li>在线算法学习试题 <a href="https://acm.sjtu.edu.cn/OnlineJudge/" target="_blank" rel="noopener">https://acm.sjtu.edu.cn/OnlineJudge/</a></li></ol><hr><h1 id="运维相关"><a href="#运维相关" class="headerlink" title="运维相关"></a>运维相关</h1><ol><li>运营监控  <a href="http://www.tingyun.com/" target="_blank" rel="noopener">http://www.tingyun.com/</a></li><li>运维 — jumpserver</li><li>青松抗D — DDOS 解决方案</li></ol><hr><h1 id="其他小工具"><a href="#其他小工具" class="headerlink" title="其他小工具"></a>其他小工具</h1><ol><li>抓包工具 charles -(配置无线手动代理,本机IP,端口8888)</li><li>动态生成banner   <a href="http://patorjk.com/" target="_blank" rel="noopener">http://patorjk.com/</a></li><li>多人协作文档(石墨文档) <a href="https://shimo.im/" target="_blank" rel="noopener">https://shimo.im/</a></li><li>免费代理网站,越狱  <a href="https://www.ngrok.cc/" target="_blank" rel="noopener">https://www.ngrok.cc/</a></li><li>linux分屏工具: tmux</li></ol><hr><h1 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h1><ol><li>spring 官网    <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></li><li>maven 类库(maven repository)  <a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful架构</title>
      <link href="/2017/08/03/2017-08-03-restful-jia-gou/"/>
      <url>/2017/08/03/2017-08-03-restful-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h1><p><strong>==(一)观点==</strong></p><hr><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p><strong>1.起源</strong></p><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p><p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p><strong>2.名称</strong></p><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。如果一个架构符合REST原则，就称它为RESTful架构。</p><p><strong>3.资源（Resources）</strong></p><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><p><strong>4.表现层（Representation）</strong></p><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><p><strong>5.状态转化（State Transfer）</strong></p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。<br>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><p><strong>6.综述</strong></p><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><p>　<br><strong>7.误区</strong></p><p>RESTful架构有一些典型的设计误区。</p><p>最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： POST /accounts/1/transfer/500/to/2</p><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务</p><p>POST /transaction HTTP/1.1</p><p>Host: 127.0.0.1</p><p>from=1&amp;to=2&amp;amount=500.00</p><p>　　<br>另一个设计误区，就是在URI中加入版本号：</p><p>　　<a href="http://www.example.com/app/1.0/foo" target="_blank" rel="noopener">http://www.example.com/app/1.0/foo</a></p><p>　　<a href="http://www.example.com/app/1.1/foo" target="_blank" rel="noopener">http://www.example.com/app/1.1/foo</a></p><p>　　<a href="http://www.example.com/app/2.0/foo" target="_blank" rel="noopener">http://www.example.com/app/2.0/foo</a>　　</p><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。</p><p>版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）：</p><p>　　Accept: vnd.example-com.foo+json; version=1.0</p><p>　　Accept: vnd.example-com.foo+json; version=1.1</p><p>　　Accept: vnd.example-com.foo+json; version=2.0　　</p><hr><hr><p><strong>==(二) 观点==</strong></p><p>REST本身不是架构，只是一种架构风格，理解它的时候要参考这个架构风格出现的环境所施加的约束条件。</p><p>REST的目的是“建立十年内不会过时的软件系统架构”，所以它具备三个特点：</p><ol><li><p>状态无关 —— 确保系统的横向拓展能力</p></li><li><p>超文本驱动，Fielding的原话是”hypertext-driven” —— 确保系统的演化能力</p></li><li><p>对 resource 相关的模型建立统一的原语，例如：uri、http的method定义等 —— 确保系统能够接纳多样而又标准的客户端</p></li></ol><p><strong>从另外一个角度看</strong></p><p>==第一条保证服务端演化==</p><p>==第三条保证客户端演化==</p><p>==第二条保证应用本身的演化，这实在是一个极具抽象能力的方案==</p><hr>]]></content>
      
      
      <categories>
          
          <category> 基础知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间管理方法论</title>
      <link href="/2017/08/02/09-fang-fa-lun/01-gong-zuo-fang-fa/2017-08-02-shi-jian-guan-li-fang-fa-lun/"/>
      <url>/2017/08/02/09-fang-fa-lun/01-gong-zuo-fang-fa/2017-08-02-shi-jian-guan-li-fang-fa-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><hr><p>时间管理有很多种方法，而GTD（全称：Getting Things Done）就是其中一套行之有效的方法，也是现在最受欢迎的方法。Getting Things Done翻译成中文就是“把事情做完”，GTD的核心理念概括就是 “通过记录的方式把头脑中的各种事情移出来，然后整理安排自己去执行”。GTD的核心步骤为五步：收集、处理、管理、执行、回顾。</p><p><img src="http://otferhktu.bkt.clouddn.com/time-manage.png" alt="time-manage"></p><hr><ul><li><strong>1.收集 —— 收集记录</strong></li></ul><p>人的大脑能储存很多东西，但有限，不要相信某事情发生后过了一段时间你还能记得，释放大脑的储存负载，让大脑着重于去思考，平时有什么信息、任务和灵感要在忘记之前用工具记录下来，使用的工具要尽可能的方便，易用，便捷。</p><ul><li><strong>2.处理 —— 处理分类</strong></li></ul><p>只有及时处理信息，对信息及时做出决定和归纳成类，你才能避免信息的堆积和碎片化，处理信息时采用二分钟法则和四象限法则，二分钟方法就是如果一件事情两分钟内能解决的事情，无论是何种事情，马上着手解决掉，如果不能再进行分类。分类则采用四象限法则，四象限法则是把工作按照重要和紧急两个不同的程度划分成四个“象限”：既紧急又重要、重要但不紧急、紧急但不重要、既不紧急也不重要。</p><p><img src="http://otferhktu.bkt.clouddn.com/time-classify.png" alt="time-manage"></p><ul><li><strong>3.计划 —— 计划安排</strong></li></ul><p>除了既有的日程安排外，可以设定每日，每周，每月，每年你需要完成的重大事件，把他们排进日程表。每天要做的事件采用三只青蛙理论，前天晚上睡觉前设定第二天最重要的三件事，起床后就可以开始着手这三件事了（同理可用于每月的“三只青蛙”, 每季度的“三只青蛙”，每年的“三只青蛙”）。每周要做的事采用习惯21天效应，一件事只要坚持21天就能习惯成自然，成为一种习惯。每月要做的事采用日历行程表的方法，将每月要做的事排进日程表。每年要做的事采用原望清单法，让自己每年都有收获和进步。</p><ul><li><strong>4.执行 —— 坚决执行</strong></li></ul><p>执行是Getting Things Done最关键的一步，也是成功与否的关键，要言行一致，制定了计划就一定得做到，这能很好地提升你的自我认同感。执行时你应当在不分心的情境下，一次只执行一件事，既不要多线工作，也不要让你的工作突然中断。采用番茄工作法，将番茄时间设为25分钟，专注工作，中途不做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息5分钟继续番茄时钟，每4个番茄时段可多休息一会儿。番茄工作法极大地提高了工作的效率，还会有意想不到的成就感。</p><p><img src="http://otferhktu.bkt.clouddn.com/time-plan.png" alt="time-manage"></p><ul><li><strong>5.回顾 —— 回顾检查</strong></li></ul><p>目前我采用的是一周回顾一次，采用PDCA循环法对长期目标、中期目标和短期目标进行回顾，对工作和其它事情进行回顾，看看哪里做的不好，需要改进，重新做出调整计划。这样能使得计划更有效地进行，更加合乎工作程序的逻辑。</p><p><img src="http://otferhktu.bkt.clouddn.com/time-PDCA.png" alt="time-manage"></p>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
